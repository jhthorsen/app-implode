#!/usr/bin/env perl
package App::implode::cli;
use Mojo::Base -strict;

use Archive::Tar;
use File::Which ();
use Module::CPANfile;
use Mojo::File 'path';
use Mojo::JSON qw(false true);
use Mojo::UserAgent;

our $IMPLODE_EXE_PATH = path(__FILE__)->to_abs;

sub verbose { shift->{verbose} //= $ENV{APP_IMPLODE_VERBOSE} ? 0 : -t STDOUT }

sub ua {
  my $self = shift;
  $self->{ua} ||= do {
    my $ua = Mojo::UserAgent->new->max_redirects(3);
    $ua->proxy->detect;
    $ua;
  };
}

# Create the output executable
sub bundle {
  my $self     = shift;
  my $exploder = $self->code('exploder');
  my $id       = path($self->{out})->basename;

  $exploder =~ s!^sub.*\@_;!\{my \$id='$id';!s;
  $exploder =~ s!^\s+!!mg;
  $exploder =~ s!\n!!g;

  open my $OUT, '>', $self->{out} or die "Could not write $self->{out}: $!\n";
  warn sprintf "Generating $self->{out} with embedded bzip archive...\n" if $self->verbose;
  print $OUT "#!/usr/bin/env perl\n", $exploder, "\n__END__\n";
  $self->tarball->write($OUT);    # write tarball after __END__
  close $OUT;
  chmod 0755, $self->{out};
  warn sprintf "$self->{out} is generated.\n" if $self->verbose;
}

# Extract the source code of method inside this file
sub code {
  my ($self, $name) = @_;
  open my $FH, '<', $IMPLODE_EXE_PATH or die "Read $IMPLODE_EXE_PATH\: $!";
  return join '', grep { /^sub $name/ .. /^\}/ } <$FH>;
}

# Download dependencies
sub download_deps {
  my $self    = shift;
  my $prereqs = Module::CPANfile->load('cpanfile')->prereqs;
  my $runtime = $prereqs->requirements_for(qw(runtime requires));

  for my $m ($runtime->required_modules) {
    my $v   = $runtime->requirements_for_module($m);
    my $url = Mojo::URL->new('https://fastapi.metacpan.org/v1/download_url');
    push @{$url->path}, $m;
    $url->query(version => $v) if $v;
    my $res = $self->ua->get($url)->res;
    die "Failed to fetch metacpan data for $m ($v): @{[$res->error->{message}]}\n" if $res->error;
    my $meta = $res->json;
    die "Could not find any match on metacpan for $m ($v)\n" unless $meta->{download_url};
    my $dist_name = path($meta->{download_url})->basename;
    my $local_file = path(qw(local implode), $dist_name);
    $self->{deps}{$dist_name} = $local_file;
    next if -e $local_file;
    warn sprintf "Downloading $dist_name to $local_file\n" if $self->verbose;
    $res = $self->ua->get($meta->{download_url})->res;
    die "Failed to fetch $url: @{[$res->error->{message}]}\n" if $res->error;
    path($local_file->dirname)->make_path unless -d path($local_file)->dirname;
    $local_file->spurt($res->body);
  }
}

# Returns true if a directory is empty
sub dir_is_empty {
  my ($self, $dir) = @_;
  opendir(my $DH, $dir) or return 1;
  not scalar grep {/\w/} readdir $DH;
}

# This sub is used inside the generated script
sub exploder {
  my ($self, $name) = @_;
  require Archive::Tar;
  require File::Path;
  require File::Spec;

  warn "[implode] cd $name; tar -xfz $0\n" if $ENV{APP_EXPLODE_VERBOSE};

  my $tar = Archive::Tar->new;
  $tar->read(
    do {
      open my $FH, '<', $0;
      my $m = 0;
      \join '', grep { $m++ if /^__END__\r?\n/ || $m; $m > 1; } <$FH>;
      }
  );

  $tar->setcwd($name);
  $tar->extract or die "[implode] Could not extract $0: @{[$tar->error]}";
}

# Create a tarball of all the downloaded dists
sub tarball {
  my $self = shift;
  my $tar  = Archive::Tar->new;
  my ($dist, $meta);

  # TODO: This should probably be more dynamic
  system "$^X Makefile.PL";
  system 'make dist';
  $meta = Mojo::JSON::decode_json(path('MYMETA.json')->slurp);
  $dist = sprintf '%s-%s.tar.gz', @$meta{qw(name version)};
  die "Failed to create $dist" unless -e $dist;
  $tar->add_data(cpanm => path(File::Which::which('cpanm'))->slurp);
  $tar->add_data($dist, path($dist)->slurp);
  $tar->add_data($_ => path($self->{deps}{$_})->slurp) for keys %{$self->{deps}};
  $tar;
}

# The script starting point
sub run {
  my $self = shift;

  $self->{deps}   = {};
  $self->{script} = shift or die "Usage: implode myapp.pl [path/to/outfile.pl]\n\n";
  $self->{out}    = shift || path($self->{script})->basename;
  -r $self->{script} or die "Cannot read '$self->{script}'.\n";
  -e $self->{out} and die "Outfile '$self->{out}' already exists.\n";

  $self->download_deps;
  $self->bundle;

  return 0;
}

exit((bless {})->run(@ARGV)) unless defined wantarray;
no warnings;
'App::implode::cli';
